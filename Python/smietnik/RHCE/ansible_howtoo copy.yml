*************************************
************ HowToo *****************
*************************************
# dla ułatwienia pisania w vim warto zainstalować
:set syntax=whitespace    ## pokazuje spacje w pliku


yum install -y vim-ansible
ansible-doc -l              *** list of al modules
ansible-doc <modulename>
ansible-doc -s <modulename> *** tak jakby pokazuje gotowy przykład dla playbooka z wszystkimi parametrami

*************************************
************ Users ******************
*************************************

### dodanie uzytkownika 'user'
  useradd -u 1111 user

### ustawienie hasla dla uzytkownika 'user'
  passwd user

### dodanie istniejacego uzytkownika 'user' do grupy wheel
  usermod -aG wheel user

**** ssh connection without pass *****
  --- generowanie klucza ssh ---
  ssh-keygen [default 3x enter]

  --- kopiowanie klucza ssh ---
  ssh-copy-id host (ip,nazwa z /etc/host/ip itp)

### modyfikacja sudoers dla uzytkownika ansible 'user'
# cat /etc/sudoers.d/user
  user ALL=(ALL) NOPASSWD: ALL

  *** example:
  # cat /etc/sudoers.d/ansible
      ansible ALL=(ALL) NOPASSWD: ALL

*************************************
********* Installation **************
*************************************
### instalacja ansible
  yum install ansible

  /> which ansible
  /> ansible --version

### instalacja python2
  yum install -y python2 apel-release [host docelowy]

 !!! ansible 2.9 ver 2.10 ma ograniczoną ilość modułów teraz nazywa się core !!!
 
## instalacja starej wersji
sudo yum install python2-pip python2-devel python ## albo yum provides pip3

sudo pip2 install pip --upgrade
sudo pip2 install ansible==2.9.27.0


*************************************
********* Configuration *************
*************************************

## 1-4 tak maja pierwszenstwo ###
  1. /etc/ansible/ansible.cfg
  2. ~/ansible.cfg
  3. ~/.ansible.cfg
  4. $ANSIBLE_CONFIG >>> test: echo $ANSIBLE_CONFIG

# ważne zmienne przyspieszajace ANSIBLA

callback_whitelist = profile_tasks  # zmienna dodawana ansible.cfg
                                    # pokazuje czas realizacji taskow

log_path = /var/log/ansible.log # logowanie do pliku 
                                # zmienna ustawiana w ansible.cfg

forks = 5   # determinuje na ilu serverach odrazu jest wykonywany task nr 1
          # zwiększając ilość możemy przyśpieszyć działanie playboka ale 
          # trzeba wiedzieć czy siec wyrobi
          # zmienna w ansible.cfg

serial: 0 default # zmienna ustawiana w playbook np po hosts
serial: 3 # mozna ustawić wtedy idzie na trzy nawet jak się wywali na host1 ale już nie pojdzie na pozostałe
serial:   # jezeli task1 się udaje to idzie na 30% i przy trzecim jak poszło ok to na pozostałe  
  - 1
  - 30%
  - 100%

[ssh_connection]    # tworzy tunel w którym wszystkie SSH są przekierowywane
pipelining = True   # zmienna w ansible.cfg

# normalnie
  task1 ------ ssh 1--->                   HOST
        <----- answer --- [zamykane]
  task2 ------ ssh 2--->                   
        <----- answer --- [zamykane]
  ...

  !!! example ansible.cfg !!!

      [defaults]
      inventory = /home/student/inventory
      log_path = /home/student/ansible.log
      callback_whitelist = profile_tasks

      [ssh_connection]
      pipelining = True

      [privilege_escalation]
      #become=True  ---> jeżeli tej opcji nie ma nalezy ją dodać w playbook lub jako flage -b/--become:  ansible all -b/--become -m shell -a 'id'
      become_method=sudo
      become_user=root
      become_ask_pass=False



# moduł MITOGEN

## lokalizacja modułów
/usr/lib/python3.6/site-packages/ansible/modules/

*************************************
********* Documentation *************
*************************************
ansible-doc -l              *** list of al modules
ansible-doc <modulename>
ansible-doc -s <modulename> *** tak jakby pokazuje gotowy przykład dla playbooka z wszystkimi parametrami

docs.ansible.com            *** website
********* Inventory *****************
*************************************

ansible localhost -m .....   # jeżeli chcemy coŚ chcemy zmienić na lokalnej maszynie 

***** check inventory

### wyswietlenie hostow zawartych w pliku inventory [default = hosts]
--- wszystkich = all lub ungrouped

  ansible all -i <inventory> --list-hosts
  ansible '*' -i <inventory> --list-hosts
  ansible ungrouped -i <inventory> --list-hosts

--- lista hostów z grupy = web 
  ansible web --list-hosts

--- lista hostow z grup zaczynajace sie na litry dh
  ansible dh* --list-hosts

### example of inventory vs ansible user
### !!! ansible > 2.0 ansible_user in ansible < 2.0 ansible_ssh_user
 

 ## group and connection
  [mygr]
  dhost0
  dhost1 ansible_user=root ansible_connection=ssh
  dhost2 ansible_user=root ansible_connection=winrm                                 *** ansible moze uzywac tylko root > ssh-copy-id root@<host lub ip>

      user ---> ansible_host ---> ansible-root ---> dhost2

  dhost3 ansible_become=true ansible_become_pass=password                   *** user musi moc zrobic sodo su -
      user ---> ansible_host ---> ansible-user --- > sudo-root ---> dhost3
      
  dhost4 ansible_user=root ansible_port=2222                                *** kiedy zmienimy port ssh na 2222
  dhost5 ansible_user=root ansible_port=2222 
  dhost6 ansible_user=root ansible_port=2222
  [control]
  dhostX ansible_connection=local                                           *** ansible_connection=local or ssh

  >>> shorter recording 
      [mygr]
      dhost0
      dhost[1:2] ansible_user=root      
      dhost3 ansible_become=true ansible_become_pass=password
      dhost[4:6] ansible_user=root ansible_port=2222
      [control]
      dhostX ansible_connection=local
      dhostX2 ansible_connection=winrm 

## group of vars 
    ### good practice is create dir group_vars 
    !!!! nie musimy robić include dla tego katalogu

    *****  najlepsza praktyka jest zapis vars'ow w osobnych plikach w katalogach:
                                               hosta_vars
                                                |__host2 
                                                |__host3
                                               group_vars 
                                                |__mygr    example: ---
                                                |                   ansible_user=root
                                                |
                                                |__test  example: ---
                                                |                   ansible_become=true
                                                                    ansible_become_pass=password
                                                
                      .../hosts
                          [group1]
                          192.168.1.1
                          [group2]
                          useef.net.com

                          ... group_vars
                              |
                              |
                              |_ files that named like group from inventory
                                    |
                                    group1  #zawartość:
                                      va1: Adam
                                      var2: Nowak
                                    group2  #zawartość:
                                      var1: Czesiek
                                      var2: Sowa
[mygr]
dhost[1:2] ansible_user=root      
dhost[3:5] ansible_user=root ansible_port=2222
[second]
dhost[6:8] ansible_e=true ansible_become_pass=password

>>> var recording 
    [mygr]
    dhost[1:2]       
    dhost[3:5] ansible_port=2222
    [mygr:vars]
    ansible_user=root

    [second]
    dhost[6:8]  
    [second:vars]
    ansible_become=true
    ansible_become_pass=password

    [all:vars]                      *** pierwszenstwo maja zmienne indywidualne lub [<grup_name>:vars]
    ansible_port=2222

## with children declaration
[mygr]
dhost[1:2]       
dhost[3:5] ansible_port=2222
[mygr:vars]
ansible_user=root

[second]
dhost[6:8]  
[second:vars]
ansible_become=true
ansible_become_pass=password

[linux:children]                        *** children declaration
mygr        # tu podaje się nazwy grup ktore chcemy zagniezdzić w grupie "linux"
second

>>> hosts as hosts.yml                  *** mozna równiez uzywac tego formatu or json
    ---
    mygr
      hosts:
        dhost1:
        dhost2:   
        dhost3:
          ansible_port=222
        dhost4:
          ansible_port=222
        dhost5:
          ansible_port=222
        vars:
          ansible_user=root
(...)
    linux:
      children:                        *** children declaration
        mygr
        second


-----ansible config--------
### podanie lokalizacji do pliku xxx.cfg
  asible -v <path to ansible.cfg>
  !!! te dane jeżeli są w playbooku to mają wyższy priorytet
  become_user: user           *** specifies which user account to use on remote host (good idea is to use the same user on all hosts)
  remote_user:                *** 
  become: yes  or True               *** powyzszy user jako root

  become_ask_pass:
  inventory:
  
***************** configuration needed for permissiones *****************
  -----privilage eskalation--------
  example section in ansible.conf   !!! te dane jeżeli są w playbooku to mają wyższy priorytet
    [privilage_escalation]
    become=True  ---> jeżeli tej opcji nie ma nalezy ją dodać w playbook lub jako flage -b/--become:  ansible all -b/--become -m shell -a 'id'
    become_method=sudo
    become_user=root
    become_ask_pass=False # na egzaminie true
    become_pass=password # password tu można podać

    !!! z lini poleceń ten przełacznik powoduje ze pyta o haslo:
    --ask-become-pass
q
  For managed hosts you can create file:
    ---- /etc/sudoers.d/user
    user ALL=(ALL) NOPASSWD: ALL
  *** example
    # cat /etc/sudoers.d/ansible
      ansible ALL=(ALL) NOPASSWD: ALL
    
*************************************************************************

*************************************
********* Run Playbook **************
*************************************
 ### check syntax /check itp

  ansible-playbook -i <inventory> <playbook_name>.yml --syntax-check                      *** check syntax
  ansible-playbook -i <inventory> -C <playbook_name>.yml                                  *** Dry run -- do nothing on destination hosts

  ansible-playbook -i <inventory> --step <playbook_name>.yml                              *** playbook will be executed step-by-step with quastion
  ansible-playbook -i <inventory> --start-at-task=<task_name> <playbook_name>.yml         *** uruchamia od danego taska
  ansible-playbook -i <inventory> --step --start-at-task=<task_name> <playbook_name>.yml  *** uruchamia od danego taska ale też step-by-step

  ansible-playbook -i <inventory> <playbook_name>.yml --check                             *** uruchomienie w trybie sprawdzenia wykonuje ale nic nie robi na hosie docelowym
  ansible-playbook -i <inventory> <playbook_name>.yml --limit test_hosts                  *** ograniczenie playbook'a do okreslomych hostow
  ansible-playbook -i <inventory> <playbook_name>.yml -b                                  *** przełącza usera na root'a 
                                                                                              [or]
                                                                                                ustawic opcje w ansible.cfg
                                                                                                become_user=root

  ### Verbose playbook output
  ansible-playbook -i hosts -v <playbook_name>.yml       ### you can use 1x v or more, max 3x v  for example: -vvvv
  ansible-playbook -i hosts -vv <playbook_name>.yml      ### good practice is use 2x vv
    

*************************************
********* Ad-hoc Command ************
*************************************

  playbooks - do ustandaryzowanych dzialan
  ad-hoc command - diagnozania, operacji na duzej ilosci hostow

*************************************
******** Commands/shell/modules *****
*************************************

### colors
  green --> success                                             *** jezelijuz cos jest jak ma byc to Ansible nie robi tego jeszcze raz 
  yellow --> success with changes
  red --> failur

ansible <all lub nazwa grup> -m <module> -a <option>

    ansible all -a <command>                    *** ansible all -a "/sbin/reboot"
      ansible all -a uptime         *** uptime hosta
      ansible all -a "tail /var/log/messages"   *** tail z p[liku
      ansible all -a "rpm -qa httpd" -o         *** czy rpm jest zainstalowany /-o wyswietlenie w jednej lini

    ansible all -m ping
    ansible all -m ping -o                       *** -o --> ping in one line
    ansible all -m ping --limit <hostname>       *** ograniczene do wskazanego hosta
    ansible all -m user -a 'name=john group=główna groups=dodatkowe'
    ansible all -m ping -o -e 'ansible_user=user ansible_become=true ansible_become_pass=password' *** dodanie parametrow kiedy uzywamy ctl

    *** jezeli pomijamy -m <module> to jest traktowany jak byśmy wpisali -m command
    *** ansible all -a "rpm -qa | grep -i http" ** bez wskazania modułi zadziałą ale bez "|>; itp" dla pełnego działania komend konieczny jest moduł 'shell'

    ansible mygr -m shell -a uptime
    ansible all -m shell -a "rpm -qa | grep -i http"
    ansible all -m shell -a env

    ansible mygr -m shell -a "hostname;uname -a" *** kiedy polecenie z flaga lub z "|" wtedy uzywamy "<command>"
    ansible]# ansible dhost2 -m shell -a 'd=`date +%Y%m%d`;cp -p /tmp/test /tmp/test.${d}'        *** backup pliku

     
 --- debug
    ansible mygr -m debug --arg='msg="This is a  test"' *** msg wyswietla commende ="xxx"
     or
      ansible mygr -m debug -a 'msg="This is a  test"'

    ansible mygr -vvv -m debug --arg='msg="This is a  test" verbosity=3'    *** polecenie zostanie wykonana tylko jak -vvv bo verbosity=3

*************************************
********* Modules **************
*************************************
file - a directory should exist
yum - a package should be installed
service==systemd - a service should be running # lepiej używać systemd
template - render a config file from a template
get_url - fetch an archive file from a URL
git - clone a source code repository

#raw:
  ansible all -m raw -a 'hostname'  # to nie używa pythona wiec mozna odpalić komendy typowo bash

#debug:
  msg - wyświetlanie komunikatów przy debagu
  var - wyświetlanie wartości zmiennej

#stat:
  pobiera informacje o pliku różne

example1
  - name: check if /tmp/{{ APPSERVER }}.{{ ServerName }}.{{ InstanceName }} exists
    stat:
      path: '/tmp/{{ APPSERVER }}.{{ ServerName }}.{{ InstanceName }}'
    register: st_runtime_instance
  - debug:
      msg: "Itcam is installed for instance {{ InstanceName }}"
    failed_when: st_runtime_instance.stat.isdir is defined and st_runtime_instance.stat.isdir

example2


#setup:
  ansible <host or group> -m setup                             *** dane o host'e
  ansible all -i hosts -m setup | grep ansible_distrib         *** module setup vs grep 
  ansible all -i hosts -m setup | grep ansible                 *** pokaze liste zmiennych ktore mozna wykozystac z setupe
  ansible all -i hosts -m setup -a 'filter=ansible_kernel'     *** uzycie setup z parametrem 'filetr'
  ansible all -m setup -a 'gather_subset=!all,!any,network,virtual' ### Possible values: `all', `min',`hardware', `network', `virtual', `ohai', and `facter'

  example: *** odpytanie o adres ip
  ---
  - name: playbook na brudno
    hosts: dhost2 dhost3

    tasks:
    - name: show var
      debug:
        msg: "{{ ansible_default_ipv4.address }}"
#script:
      *** moduł umożliwiający wywoływanie scryptow

#file:                                                          *** operacje na files/directories itp.
  ansible all -m file -a 'path=/tmp/test state=directory'      *** tworzenie katalogu
  ansible all -m file -a 'path=/tmp/test state=absent'         *** kasowanie katalogu
  ansible all -m file -a 'path=/tmp/test state=touch'          *** state=touch tworzy lub modyfikuje plik
  ansible all -m file -a 'path=/tmp/test state=file mode=777'  *** state=file > modyfikuje plik jezeli istnieje | mode=777 > zmienia permissions
  ansible all -m file -a 'path=/tmp/test state=absent'         *** + state=absent to ze nie ma pliku tez jest jako success i koloruje na zielono
  
    - name: Create .ssh directory in user skeleton  *** tworzenie pliku o okreslonych uprawnieniach
    file:
      path: /etc/skel/.ssh
      mode: 0700
      owner: root
      group: root
      state: directory

#copy:
  backup=yes/no           *** jezeli kopiowany plik rozni sie od docelowego tworzona jest copia dest 
  ansible all -m copy -a 'src=/etc/ansible/srctmp.j2 dest=/tmp/' *** nie nadpisze pliku juz plik ma identyczna zawartosc
  ansible all -m copy -a 'content="tekst do skopiowania do pliku\n" dest=/tmp/file.txt' *** kopiuje tekst (kontente) do pliku, jezeli nie ma pliku to go utwozy

#lineinfile:               *** zmiana lini w pliku, dodaje/zamienia
---
- name: Lab playbook
  hosts: all
  gather_facts: true

  tasks:
  - name: insert line
    lineinfile:
      path: /etc/default/grub
      backup: yes
      state: present
      regexp: '^GRUB_CMDLINE_LINUX='    ### powoduje ze linia z takim wzorcem zostanie zamieniona
      line: 'GRUB_CMDLINE_LINUX="crashkernel=auto resume=UUID=226eae0b-66d1-48e5-9fc1-d547d0d94afc"'
  - name: grub change implementation
    shell: "grub2-mkconfig -o /boot/grub2/grub.cfg"

  #result: block with comments
    # BEGIN ANSIBLE MANAGED BLOCK
    CATALINA_OPTS="$CATALINA_OPTS -Djdk.tls.client.protocols=TLSv1.2"
    CATALINA_OPTS="$CATALINA_OPTS -Dhttps.protocols=TLSv1.2"
    # END ANSIBLE MANAGED BLOCK

  #result: block with comments
    #--- begin of block: Due to TASK1000000 below lines were added --- ANSIBLE MANAGED BLOCK
    CATALINA_OPTS="$CATALINA_OPTS -Djdk.tls.client.protocols=TLSv1.2"
    CATALINA_OPTS="$CATALINA_OPTS -Dhttps.protocols=TLSv1.2"
    #--- end of block: Due to TASK1000000 below lines were added --- ANSIBLE MANAGED BLOCK

...

#konfiguracja serwera base -- dodanie linii na końcu
ansible localhost -m lineinfile -a 'path=/etc/chrony.conf line="local stratum 10"'
ansible localhost -m lineinfile -a 'path=/etc/chrony.conf line="allow 10.10.0.0/16"'
#zmiana pliku konfiguracyjnego /etc/chrony.conf zastąpienie okreslonej linii
ansible all -m lineinfile -a 'path=/etc/chrony.conf regexp="pool2.centos.pool.ntp.org iburst" line="server base iburst"'

#command is default module if we skip -m command it will work fine
  ansible mygr -m command -a uptime == ansible mygr -a uptime
  ansible mygr -m command -a 'hostname' -o                      *** -o --> result in on line

  ansible]# ansible all -m command -a 'touch /tmp/srctmp.j2 creates=/tmp/srctmp.j2' *** creates --> create file if it doesn't exist (nawet jak pliki sa rozne)
  ansible]# ansible all -m command -a 'rm /tmp/srctmp.j2 removes=/tmp/srctmp.j2'    *** removes --> rm file if it exist (if not it do nothing and show success)

#yum:
  ansible mygr -m yum -a 'name=httpd state=present' -b *** instalacja pakietu poprzez modul yum, -b przelacz na root!
  ansible mygr -m yum -a 'name=httpd state=latest' -b *** 
  ansible mygr -m yum -a 'name=httpd state=absent' -b *** usuniecie pakietu poprzez modul yum, -b przelacz na root!

#systemd: restart serwsu   **** zastąpił service
 - name: Make sure a service is running
   systemd:
     state: started
     name: httpd
 - name: restarted service
   systemd:
     state: restarted
     name: httpd

#fetch:      *** module to copy file from remote location
  ansible mygr -m fetch -a 'src=/tmp/test_modules.txt dest=/tmp/test/'    *** po operacji /tmp/test/<host-ip-or-name>/tmp/test_modules.txt
  ansible mygr -m fetch -a 'src=/tmp/test_modules.txt dest=/tmp/test/ flat=yes'    *** po operacji /tmp/test_modules.txt

  ansible all -m fetch -a 'src=/etc/hosts dest=/tmp'  # backup
  ansible all -m copy -a 'src=/tmp/{{ hosts }}/etc/hosts dest=/etc/hosts' # odzyskanie z backup

# reboot:
  *** moduł do reboota maszyny, można dodać opóźnienie
  !!! jezeli jest w środku tasku np jest to task2 to nie przerwie działania playbooka
      wiec po reboote playbook bedzie kontynuowany

#service:
  ansible mygr -m service -a 'name=atd state=restarted enabled=yes' *** restart service=atd or started/stopped

#vars in command line
  ansible-playbook -i hosts palybook_2.yum -e 'item="Wartosc zmiennej item"'   *** dodanie wartosci zmiennej znajdujacej sie w playbooku z command line {{ item }}
 or
  ansible-playbook -i hosts palybook_2.yum --extra-vars='item="Wartosc zmiennej item"'

  ansible-playbook -i hosts palybook_2.yum -e @file.yml                       *** dodanie zmiennej {{ extra_var }} z pliku file.yml 
                                                                                   example: ---
                                                                                            extra_var: vars value
#group:
  --- modul do tworzenia group
  name:
  uid:
  gid:
  state: present

#pids:
  ansible all -i hosts -m pids -a "name=java"       *** show pid of java process -->tomcat/jboss
  ansible all -i hosts -m pids -a "name=httpd"      *** show pid of httpd process  -->apache

#archive: --moduł do archiwizacji 
  ansible all -m archive -a 'path=/etc dest=/backup/arch.zip format=zip'  ## format=gzip/gz itp

### LVM
#lvg tworzy grupe vg and dolacza partycje
- name: Create a volume group on top of /dev/sda1 with physical extent size = 32
  lvg:
    vg: vg.services
    pvs: /dev/sda1
    pesize: 32  # physical extent size = 32MB jak nie chcemy to pomijamy

*************************************
******** ad-hoc scripts *************
*************************************
examples:
#!/bin/bash
#Instalacja Apache
ansible poznan -m dnf -a 'name=httpd state=latest'
#Konfiguracja firewalld
ansible poznan -m firewalld -a 'service=http state=enabled permanent=yes immediate=yes'
#Zawartosc index.html
ansible poznan -m copy -a 'dest=/var/www/html/index.html content="Witaj w swiecie Ansible"'
#Uruchomienie serwisu
ansible poznan -m systemd -a 'state=start enabled=yes name=httpd'

examples: # chronyd
#!/bin/bash
#konfiguracja serwera base
ansible localhost -m lineinfile -a 'path=/etc/chrony.conf line="local stratum 10"'
ansible localhost -m lineinfile -a 'path=/etc/chrony.conf line="allow 10.10.0.0/16"'
#restart usługi na base
ansible localhost -m systemd -a 'name=chronyd state=restarted'
#zmiana pliku konfiguracyjnego /etc/chrony.conf
ansible all -m lineinfile -a 'path=/etc/chrony.conf regexp="pool 2.pool.ntp.org iburst" line="server base iburst"'
#restart usługi
ansible all -m systemd -a 'name=chronyd state=restarted'

examples: # creating partition
#!/bin/bash
#Tworzenie partycji vdb1
ansible gdansk -m parted -a 'device=/dev/vdb number=1 state=present part_end=2GiB'
#Tworzenie filesystemu xfs
ansible gdansk -m filesystem -a 'fstype=xfs dev=/dev/vdb1'
#Tworzenie miejsca montowania
ansible gdansk -m file -a 'path=/backup owner=root group=root mode=0644 state=directory'
#Montowanie partycji
ansible gdansk -m mount -a 'path=/backup src=/dev/vdb1 fstype=xfs state=present'      ### state=mounted tak jakbyś wydał polecenie mount -a czyli bedzie podjęta pruba zamontowania


*************************************
******** Build Playbook *************
*************************************
*** parameters of running playbook

/> time ansible-playbook -i <inventory> playbook_name.yum                *** po zakonczeniu pokazuje czas realizacji playbook'a
/> ansible-playbook -i <inventory> playbook_name.yum -l host2            *** limitowanie playbooka do wskazanego hosta

*************************************
******** Playbook sections: *********
*************************************
# Target: gdzie i z jakimi ocjami odpalamy playbook
# Variable: zmienne jakie dolaczmy do playbooka lub uzywamy na docelowym hoscie
# Tasks: lista taksow, moga byc rowniez pre- i post- taski
# Handlers: ktore beda wykonane w oparciu o "notify" znajdujace sie w taskach
!!! handlers wykonuje się jezeli dany task ma status change
# Roles: lista roles

!!! w playbooku może być kilka playów # multiplaybook
  *** zmienne ograniczane są do danego playa
---
- name: playbook dla test
  hosts: test.example.net
  task:
  - name: install vsftpd
    yum: 
      name: vsftpd
  - name: enable vsftpd
    systemd: 
      name: vsftpd 
      enabled: true
- name: playbook dla server nowy
  hosts: nowy.example.net
  task:
  - name: install httpd
    yum: 
      name: httpd
  - name: enable httpd
    systemd: 
      name: httpd
      enabled: true
 
**********************************************
****** next examples: ******
!!! instalacje rpm without repo from local path
   - name: localinstall rpm
    dnf:
      name: /home/ansible/lftp-4.8.4-2.el8.x86_64.rpm
      disablerepo: '*'

****** next examples: ******
---
- name: sumple playbook
  hosts: test.example.net
  user: user
  become: yes
  become_method: sudo
  become_user: root
  task:
  - name: install vsftpd
    yum: 
      name: vsftpd
  - name: enable vsftpd
    systemd: 
      name: vsftpd
      enabled: true
  - name: create readme file
    copy:
      content: "welcome to my ftp\n"          # dodaje koniec linii
      dest: /tmp/README
      force: no
      mode: 0444

      
****** next examples: ******
---
- name: Lab playbook
  hosts: all
  gather_facts: true

  tasks:
  - name: install httpd
    yum: name=httpd state=latest 
  - name: start and enable httpd
    systemd: 
      name: httpd
      enabled: yes
      state: started 
  - name: create index.html file
    copy: 
      content: "Welkome to may web server\n" 
      dest: /var/www/html/index.html
  - name: open firewall: for httpd
    firewalld:
      systemd: http 
      immediate: yes ## ta opcja otwiera servis bez restartu czyli kolejny task jest niepotrzebny
      permanent: true
      state: enabled
  - name: Reload firewall # czasami immediate nie działą wiec lepiej zrobic restart
    systemd: 
      name: firewalld
      state: restarted 
...
****** next examples: ******
# port as variable
- name: dodanie portu {{ port_www }}
  firewalld:
    port: "{{ port_www }}/tcp"
    permanent: yes
    immediate: yes
    state: enabled



****** next examples: ******
- name: zarzadzanie userami
  hosts: all
  tasks:
    - name: tworzenie grupu
      group:
        name: quest
        state: present

    - name: dodawanie usera
      user:
        name: bob
        group: quest
        state: present

    - name: tworzenie katalogu
      file:
        path: /share
        state: directory
        owner: bob
        group: quest
        mode: 0770

### otwarcie okreslonego portu trzeba pamiętać o podaniu portu/protokołu
- firewalld:
    port: 8081/tcp
    permanent: yes
    state: disabled

****** next examples: ******
---
- name: my first playbook
  hosts: mygr
  gather_facts: true                        ### you can use fatcs?

  vars:                                     ### wartosc zmiennej dla tego playbook'a
    var1: 'Hello'
    var2: 'I would like to see'
  tasks:                                  
  - name: copy_file                         ### kopiowanie pliku
    copy:
      src: /etc/ansible/cptestfile.txt
      dest: /etc/ansible_test/

  - name: Create .ssh directory in user skeleton  *** tworzenie pliku o okreslonych uprawnieniach
    file:
      path: /etc/skel/.ssh
      mode: 0700
      owner: root
      group: root
      state: directory


  - name: install lynx                      *** instalacja pakietu
    yum:
      name: lynx.x86_64
      state: latest
    become_user: root                       *** instalacja paczki jaki root

  - name: template                          *** tworzenie template
    template:
      src: /etc/ansible/srctemp.j2          *** plik szablonu
      dest: /etc/ansible_test/outtemp.txt   *** plik wynikowy

****** next examples: ******

---
- name: zarzadzanie userami
  hosts: all
  vars:                       ## grupa zmiennych
    user: lob
    group: boss
    dir: /top
  tasks:
    - name: tworzenie grupu {{ group }}
      group:
        name: '{{ group }}'
        state: present 

    - name: dodawanie usera {{ user }} w grupie {{ group }}
      user:
        name: '{{ user }}'
        group: '{{ group }}'
        state: present
        
    - name: tworzenie katalogu {{ dir }}
      file:
        path: '{{ dir }}'
        state: directory
        owner: '{{ user }}'
        group: '{{ group }}'
        mode: 0770 

*************************************
********** Loops *******
********** create dic and list *******
*************************************
  ### lista/dic itd

    #Example of a list:

        schemas:
          - year1
          - year2
          - year3

    #Example of a list of hashes with single lists

        schemas:
          - year1:
              - main
              - custom
          - year2:
              - main
              - custom
              - security
          - year3:
              - main
              - custom

    #Example of a dictionary:

        schemas:
          year1:
            - main
            - custom
          year2:
            - main
            - custom
            - security
          year3:
            - main
            - custom



  ---- nested loop -----
  tasks:
   - name: copy nested loop
    copy:
      content: "Item0: {{ item[0] }} i Item1: {{ item[1] }}\n"
      dest: /tmp/nested.txt
    with_nested:
    - [ 'one', 'two' ]
    - [ 'aaa', 'bbb', 'ccc' ]

    >>> results >>> jakby każdy z każdym
    TASK [copy nested loop] **********************
          changed: [ansible2] => (item=['one', 'aaa'])
          changed: [ansible1] => (item=['one', 'aaa'])
          changed: [ansible2] => (item=['one', 'bbb'])
          changed: [ansible1] => (item=['one', 'bbb'])
          changed: [ansible2] => (item=['one', 'ccc'])
          changed: [ansible1] => (item=['one', 'ccc'])
          changed: [ansible2] => (item=['two', 'aaa'])
          changed: [ansible1] => (item=['two', 'aaa'])
          changed: [ansible2] => (item=['two', 'bbb'])
          changed: [ansible1] => (item=['two', 'bbb'])
          changed: [ansible2] => (item=['two', 'ccc'])
          changed: [ansible1] => (item=['two', 'ccc'])

   name: DEBUG
    debug: msg="{{ item[0].team_name }}: {{ item[0].applications.name }}: index: {{ item[1] }}"
    with_nested:
      - "{{ teams }}"
      - "{{ lookup('sequence', 'start=1 end='+(item[0].applications|length))|string }}"


  !!! rekomendowana forma !!!
  - name: install python
    yum: {{ item }} state=present             *** loop that do yum for each item in "loop"
    loop:
      - libselinux-python
      - libsemanage-python
    
  !! PETLA Z VARS
  vars:
    paczki:                 ## zmiena paczka jako lista
      - libselinux-python
      - libsemanage-python
  task
  - name: install python
    yum: {{ item }} 
      state: present             *** loop that do yum for each item in "loop"
    loop: '{{ paczki }}'
    

*************************************
********** Conditional Operators ****
*************************************
Equal: "{{ wartosc }} == 1024"
Less than: "{{ wartosc }} < 512"
Greater than: "{{ wartosc }} > 512"
Less than or equal: "{{ wartosc }} <= 512"
Not equal: "{{ wartosc }} != 512"
Variable exists: "{{ wartosc }} is defined"
Variable does not exist: "{{ wartosc }} is not defined"
Variable is set to yes, true or 1: "{{ wartosc }}"
Variable is set to no, false or 0: "not {{ wartosc }}"
Valu is present in a variable or array: "{{ users }} in users["db+admins"]"
Valu is present in a variable or array: "{{ users }} not in users["db+admins"]"

*** syntacs example ***   ## w obu przypadkach wynik jest ten sam
    when: rpmcurrent.stdout != "" and "'{{ rpmappname }}{{ rpmversion }}' not in rpmcurrent.stdout"
    when: rpmcurrent.stdout != "" and "vars[rpmappname + rpmversion] not in rpmcurrent.stdout"

------ and/or
"{{ wartosc }} != 512" and not {{ wartosc }}


  **** stosowanie warunku "when" ****** when is false task is skiped !!!!!
  vars: 
    centos: "centos_OS"
    ubuntu: "ubuntu_OS"

  - name: warunek
    file: path='/tmp/{{ centos }} state=present
    when: warunek == "wartosc"

    example:
        vars:
          os_c: "Centos OS"
          os_u: "Ubiuntu OS"

        tasks:
        - name: copy file
          copy:
            content: "{{ os_c }}"
            dest: /tmp/file.txt
          when: ansible_distribution == "CentOS" ## na tym samym wcięciu co moduł

        - name: copy file
          copy:
            content: "{{ os_u }}"
            dest: /tmp/file.txt
          when: ansible_distribution == "Ubuntu"


        - name: install packages if sufficent disk space
          yum:
            name: httpd
            state: latest
          with_items: "{{ ansible_mounts }}"
          when: item.mount =="/" and item.size_available > 200000000

  -------- facts look like: ----------------
      ansible2 | SUCCESS => {
    "ansible_facts": {
        "ansible_mounts": [
            {
                "mount": "/",
                "size_available": 6873034752,
            },
      ansible1 | SUCCESS => {
          "ansible_facts": {
              "ansible_mounts": [
            {
                "mount": "/",
                "size_available": 6874189824,
            },
---- result.rc == 0 --- czyli sukces operacji
  tasks:
    - name: Install patch
      yum:
        name: patch
        update_cache: yes
        state: latest
      register: result

    - name: next task     *** ten task bedzie wykonany kiedy instalacja zakończy sie sukcesem 
        ...
        ...
      when: result.rc == 0  *** oznacza sukces:

!!! register - uzywamy jeśli chcemy wykorzystać rezultat/wynik taska

# ---- moduł package - list ----

  - name: check package
    package:
      name: libnghttp2-1.33.0-3.el8_2.1.x86_64
    register: rpmshow

  - debug:
      var: rpmshow

      ### wynik = rpmshow
        ok: [server2] => {
            "rpmshow": {
                "changed": false,
                "failed": false,
                "msg": "Nothing to do",
                "rc": 0,
                "results": []
            }
        }
# ---- moduł yum - list ----

  - name: check package
    yum:
      list: libnghttp2-1.33.0-3.el8_2.1.x86_64
    register: rpmshow

  - debug:
      var: rpmshow

      ### wynik = rpmshow
      ok: [server2] => {
          "rpmshow": {
              "ansible_facts": {
                  "pkg_mgr": "dnf"
              },
              "changed": false,
              "failed": false,
              "msg": "",
              "results": [
                  {
                      "arch": "x86_64",
                      "epoch": "0",
                      "name": "libnghttp2",
                      "nevra": "0:libnghttp2-1.33.0-3.el8_2.1.x86_64",
                      "release": "3.el8_2.1",
                      "repo": "@System",
                      "version": "1.33.0",
                      "yumstate": "installed"
                  },
                  {
                      "arch": "x86_64",
                      "epoch": "0",
                      "name": "libnghttp2",
                      "nevra": "0:libnghttp2-1.33.0-3.el8_2.1.x86_64",
                      "release": "3.el8_2.1",
                      "repo": "baseos",
                      "version": "1.33.0",
                      "yumstate": "available"
                  }
              ]
          }
      }
# ---- moduł yum - list: --installed ----
  - name: check tomcat rpm
    #package:
    yum:
      list: --installed libnghttp2-1.33.0-3.el8_2.1.x86_64
    register: rpmshow

  - debug:
      var: rpmshow

        ### wynik = rpmshow
          ok: [server2] => {
              "rpmshow": {
                  "ansible_facts": {
                      "pkg_mgr": "dnf"
                  },
                  "changed": false,
                  "failed": false,
                  "msg": "",
                  "results": []
              }
      }

 *** next
    # budowa listy z atrybutów wystepujacych w results yumstate', 'equalto', 'available'
    - name: list installed and available versions of ruby 
      yum:
        list: ruby
      become: true
      when: ansible_os_family == 'RedHat'
      register: yum_output

    - name: print available ruby versions
      debug:
        msg: "{{ item.version }}-{{ item.release }}"
      loop: "{{ yum_output.results | selectattr('yumstate', 'equalto', 'available') | list }}"

    - debug: var=yum_output

 *** next
    # budowa listy z atrybutów 'stdout' wystepujacych w results z pominieciem pustych
  - set_fact:
      nosystemd_ins

 *** next
    # budowa listy z atrybutów 'stdout' wystepujacych w results !!!ale tylko ze zdefiniowanych i z pominieciem pustych
  - set_fact:
      nosystemd_instance: "{{ nosystemd_instance_name.results|selectattr('stdout', 'defined')|map(attribute='stdout')|select()|list }}"
    become: true

*************************************
********** Variables ****************
*************************************
******** Variables as dicrionary ***
*************************************
!!! Ważność zmienneych
  1. command line (-e ) or ansible configuration <-----     !!! ROLES: 
                                                      |       default ----
  2. defined by Playbook   <---------------           |-------variables  |
                                          |______________________________|
  3. inventories
  
  4. buit-in 
      *groups
      *hostsvars


!!! odwołanie do zmiennej ma miejsce poprzez {{ nazwa_zmiennej }}
!!! recomended method is to use group_vars and host_vars directories
!!! host_vars ma wyższy priorytet niż group_vars
!!! at any time you can overwrite variable from the commend line use: -e "key=value" 
    option that you can add to ansible-playbook command

******* example ********
  >/ ansible-playbook -i hosts playbook_vars_1.yml

    >>> hosts file
    [ansible@server01 ansible_lab]$ grep -v -e '^#' -e '^$' hosts 
    [webservers]
    192.168.122.149
    [tomcat]
    192.168.122.147

    >>> group dir that must be in project directory
    .../group_vars/
      it must contains files for hosts groups:
      ... webservers
        var1: Adam
      ... tomcat
        var1: Tomasz

    ***** playbook:
    ---
    - name: Lab playbook
      hosts: all
      gather_facts: true

      tasks:
      - name: insert string with {{ var1 }}
        copy:
          content: "Hello {{ var1 }}\n"
          dest: /tmp/test
...

  ******* example ********
  >/ ansible-playbook -i hosts -e "var1=Marek" playbook_vars_1.yml

    ***** playbook:
    ---
    - name: Lab playbook
      hosts: all
      gather_facts: true

      tasks:
      - name: insert string with {{ var1 }}
        copy:
          content: "Hello {{ var1 }}\n"
          dest: /tmp/test
...

******* examples ********
---
- name: playbook na brudno
  hosts: dhost2 dhost3

  vars:
    dict:
      dict_key: This is dictionary value

  tasks:
  - name: show var ver1
    debug:
      msg: "{{ dict }}"

  - name: show var ver2
    debug:
      msg: "{{ dict.dict_key }}"

  - name: show var ver3
    debug:
      msg: "{{ dict['dict_key'] }}"

*************************************
******** Variables as list ***
*************************************
---
- name: playbook na brudno
  hosts: dhost2 dhost3

  vars:
    list:
      - item1
      - item2
      - item3

  tasks:
  - name: show var ver1
    debug:
      msg: "{{ list }}"

  - name: show var ver2
    debug:
      msg: "{{ list.2 }}"

  - name: show var ver3
    debug:
      msg: "{{ list[4] | default('wrtosc domyslna kiedy nie znaleziono') }}"  **** zapis | default('') |--> moze byc pusty

*************************************
******** Variables as file ***
*************************************
---
- name: playbook na brudno
  hosts: dhost2 dhost3

  vars_files:
    - vars/file.yml         *** katalog vars musi być w katalogu projektu

       example of file:
       ---
       list:
          - item1
          - item2
       list_line:
          [ item1, item2, item3 ]
       dict:
          dict_key: This is dictionary value

  tasks:
  - name: show var ver1
    debug:
      msg: "{{ list.2 }}"

  - name: show var ver2
    debug:
      msg: "{{ dict.dict_key }}"

  - name: show var ver3
    debug:
      msg: "{{ list[0] }}"

*************************************
******** Variables as prompt ***
*************************************
---
- name: playbook na brudno
  hosts: dhost2 dhost3 

  vars_prompt:            *** po odpaleniu playbooka trzeba podac wartosc "username" z lini polecen
    - name: username      
      private: true       *** to ustawienie powinno miec miejsce kiedy pytamy o wrazliwe dane (hasla  itp.)
  tasks:
  - name: show var ver1
    debug:
      msg: "{{ username }}"

*************************************
******** Facts ***  # domyślnie są zbierane chyba że wyłaczymu !!!
*************************************
!!!!!!!!!!!
ansible <host or group> -m setup                             *** dane o host'e
  ansible all -i hosts -m setup | grep ansible_distrib         *** module setup vs grep 
  ansible all -i hosts -m setup | grep ansible                 *** pokaze liste zmiennych ktore mozna wykozystac z setupe
  ansible all -i hosts -m setup -a 'filter=ansible_kernel'     *** uzycie setup z parametrem 'filetr'
  ansible all -i hosts -m setup -a 'filter=ansible_local'       *** sprawdzenie localnych factow /etc/ansible/facts.d/

  !!!!!!!!! szukanie z * !!!!!!!!!!!!!!!!!
  ansible all -i hosts -m setup -a 'filter=ansible_*'          *** wyswietlenie wszystkich parapetrow
  ansible dhost2 -i hosts -m setup -a 'filter=ansible_mem*'    *** using "filter" to search data, you can use "*"
  ansible all -i hosts -m setup -a 'filter=*fqdn*'

********** important facts **********
  ansible_fqdn
  ansible_all_ipv4_addresses

*************************************
  aby nie ociazac systemy lepiej zbierac dane uzywajac filtra dla factow
  i wyłaczyć czytanie wszystkich 
  opcja: 
    gather_facts: false

  przykład takiego playbooka
  ---
  - name: my first playbook
    hosts: all
    gather_facts: false

    tasks:
    - name: conect test
      ping:

    - name: Pobranie wartości - rodzaj systemu
      setup:
        gather_subset: min
        filter: ansible_os_family

    - name: show rodzaj systemu
      debug:
        msg: "{{ ansible_facts.os_family }}"

    - name: Pobranie wartości - numer wersji
      setup:
        gather_subset: min
        filter: ansible_distribution_major_version

    - name: show rodzaj systemu
      debug:
        msg: "{{ ansible_facts.distribution_major_version }}"

 ...
*** next examples ***
  ---
  - name: simple playbook
    hosts: all
    gather_facts: no

    tasks:
      - name: get fact gw
        setup:
          gather_subset: network
          filter: ansible_default_ipv4
      - name: show gw
        debug:
          msg: "{{ ansible_facts['default_ipv4']['gateway'] }}"

          !! or !! msg: "{{ ansible_default_ipv4['gateway'] }}"

*** next examples ***
ansible localhost -m debug -a 'var=hostvars["localhost"]["groups"]["all"]'


*** next examples ***
---
- name: playbook na brudno
  hosts: dhost2 dhost3

  tasks:
  - name: show facts
    debug:
      msg: "{{ ansible_default_ipv4.address }}"     *** pobranie fatct jako dziennika (dictionary)
      msg: "{{ ansible_default_ipv4['address'] }}"  !!!! dobra praktyka 

*** we can create own facts
  etc/ansible/facts.d                 *** na docelowym hoscie, dane beda oznaczone jako "ansible_local"
      |__ getdate1.fact
      |__ getdate2.fact

          example of file:
            json format:
            {"date" : "Wed Jun  3 09:56:56 BST 2020"}
            ini format:
            [date]
            date=Wed Jun  3 09:56:56 BST 2020
            bash format:          *******************
            #!/bin/bash
            echo {\""date\""} : \""`date`\""}

*** next examples:
### róznica między debud: var / msg
---
- name: playbook na brudno
  hosts: all
  tasks:
  - name: show facts
    debug:
      var: ansible_default_ipv4.address  ### print zmienną var: ansible_default_ipv4.address

  - name: show facts
    debug:
      msg: >                              ### print wiadomość z wartością IP z facts: ansible_default_ipv4.address
        This is IP: {{ ansible_default_ipv4.address }}  

        !!! lub inny zapisa
      msg: "This is IP: {{ ansible_default_ipv4.address }}"

        !!! dobra praktyka { ansible_default_ipv4['address'] }}"

---
- name: playbook na brudno
  hosts: all
  tasks:
  - name: show VAR2
    debug:
      var: var2

  - name: show VAR1
    debug:
      msg: "Hello {{ var1 }}"
...


*** next examples:
*** task adding line ti file if line doesn't exist

[...]
  task: 
    - lineinfile:
      path: /etc/resolve.conf
      line: 'nameserver 10.1.156.10'

*** task running scripts
[...]
  task: 
    - name: run script on remote server
      script: /tmp/script.sh -arg1 -arg2

*** create facts.d via playbook and copy them:
---
[...]
  task: 
    - name: make facts dir
      file: path=/etc/ansible/facts.d recurse=yes state=directory

    - name: copy fact1
      copy:
        src: /etc/ansible/facts.d/getdate1.fact
        dest: /etc/ansible/facts.d/getdate1.fact
        mode: 0755

    - name: copy fact2
      copy:
        src: /etc/ansible/facts.d/getdate2.fact
        dest: /etc/ansible/facts.d/getdate2.fact
        mode: 0755

    - name: refresh facts
      setup:

  *** create facts.d via playbook for specific user
---
[...]
  task: 
    - name: make facts dir
      file: path=/home/<user>/ansible/facts.d recurse=yes state=directory owner=<user>

    - name: copy fact1
      copy:
        src: /etc/ansible/facts.d/getdate1.fact
        dest: /home/<user>/ansible/facts.d/getdate1.fact
        owner: <user>
        mode: 0755

    - name: copy fact2
      copy:
        src: /etc/ansible/facts.d/getdate2.fact
        dest: /home/<user>/ansible/facts.d/getdate1.fact
        owner: <user>
        mode: 0755

    - name: refresh facts
      setup:
        fact_path: /home/<user>/ansible/facts.d


*************************************
******** set_fact: ***
*************************************

- name: get some information
  set_fact: variable="{{ catalina_home.stdout| regex_search('[0-9]') }}"

        teraz możemy używać {{ variable }}

*************************************
******** Systems roles: role systemowe ***
*************************************
# potrzebna paczka
  rhel-system-roles
# lokalizacja roli systemowych 
  ll /usr/share/ansible/roles/

# użycie roli systemowej do wlasnych celow
  - name: uzycie roli systemowej
    kosts: all
    vars:
      - { name: httpd_can_network_connect, state: yes, persistent: yes }  ## nadpisujemy defaultowe zmienne w rolach
                                                                          ## musimy jednak sami sprawdzić jak te zmienne wygladaja
    roles:
      - linux-system-roles.selinux

# dokumentacja
  https://access.redhat.com/articles/3050101

*************************************
******** Galaxy roles: role z galaxi ***
*************************************
# instalacja roli
ansible-galaxy install geerlingguy.mysql

# lokalizacja
~/.ansible

      [ansible@wroclaw ~]$ tree .ansible/
      .ansible/
      ├── cp
      ├── galaxy_token
      ├── roles
      │   └── geerlingguy.mysql
      │       ├── defaults
      │       │   └── main.yml
      │       ├── handlers
      │       │   └── main.yml
      │       ├── LICENSE
      │       ├── meta
      │       │   └── main.yml
      │       ├── molecule
      │       │   └── default
      │       │       ├── converge.yml
      │       │       └── molecule.yml
      │       ├── README.md
      │       ├── tasks
      │       │   ├── configure.yml
      │       │   ├── databases.yml
      │       │   ├── main.yml
      │       │   ├── replication.yml
      │       │   ├── secure-installation.yml
      │       │   ├── setup-Archlinux.yml
      │       │   ├── setup-Debian.yml
      │       │   ├── setup-RedHat.yml
      │       │   ├── users.yml
      │       │   └── variables.yml
      │       ├── templates
      │       │   ├── my.cnf.j2
      │       │   ├── root-my.cnf.j2
      │       │   └── user-my.cnf.j2
      │       └── vars
      │           ├── Archlinux.yml
      │           ├── Debian-10.yml
      │           ├── Debian.yml
      │           ├── RedHat-7.yml
      │           └── RedHat-8.yml
      └── tmp

# trzeba zmodyfikowac varsy usery itp
.ansible/roles/geerlingguy.mysql/defaults/main.yml

# użycie roli systemowej do wlasnych celow
  - name: uzycie roli galaxy
    kosts: all
    roles:
      - geerlingguy.mysql

*************************************
******** Jinja2 ***
*************************************

- debug:
    msg: "{% for address in network.addresses.private_man %}\
        {% if address.type == 'fixed' %}\
          {{ address.addr }}\
        {% endif %}\
      {% endfor %}"

---
- name: playbook na brudno
  hosts: dhost2 dhost3

  tasks:
  - name: jinja2 task
    debug:
      msg: >
           --== Ansible Jinja2 statment ==--
           {# comment line -#}
           {% if ansible_hostname == "dhost2" %}
              this is host nr 2*
           {% else %}
              this is {{ ansible_hostname }}
           {% endif %}
...

*** elif
           {% if ansible_hostname == "lvn2" %}
              this is host nr 2
           {% elif ansible_hostname == "lvm3" %}
              this is host nr 3
           {% endif %}
*** example 
    - name: show rpm current version
        debug:
          msg: >
              {% if "'{{ rpmcurrent.stdout }} == {{ rpmappname }}{{ rpmversion }}'" %}
                  nothing to do current rpm rpmcurrent.stdout is equal new rpm {{ rpmappname }}{{ rpmversion }}
              {% else %}
                  current rpm version is rpmcurrent.stdout
              {% endif %}

*** condition var is defined
          ---
          - name: playbook na brudno
            hosts: dhost2 dhost3

            tasks:
            - name: jinja2 task
              debug:
                msg: >
                     --== Ansible Jinja2 statment ==--
                     {# comment line -#}
                     {% if ansible_hostname is defined %}
                        ok = {{ ansible_hostname }}
                     {% else %}
                        nok
                     {% endif %}
...
*** przypisanie wartosci do zmiennej

            tasks:
            - name: jinja2 task
              debug:
                msg: >
                     --== Ansible Jinja2 statment ==--
                     {# comment line -#}
                     {% set ansible_hostname = 'default' %} *** przypisanie wartosci do zmiennej
                     {% if ansible_hostname is defined %}
                        ok = {{ ansible_hostname }}
                     {% else %}
                        nok
                     {% endif %}

*** loop for
  ---
  - name: playbook na brudno
    hosts: dhost2 dhost3

    tasks:
    - name: jinja2 task
      debug:
        msg: >
             --== Ansible Jinja2 statment ==--
             {# comment line -#}
             {% for item in ansible_default_ipv4 %}
                IP Address entry {{ loop.index }} = {{ item }}  *** loop index - pozwala na zliczenie
             {% endfor %}
...

*** loop for and range

  tasks:
  - name: jinja2 task
    debug:
      msg: >
           --== Ansible Jinja2 statment ==--
           {# comment line -#}
           {% for item in range(1,11) %}
              number {{ item }}
           {% endfor %}

*** break/continue  command
  tasks:
  - name: jinja2 task
    debug:
      msg: >
           --== Ansible Jinja2 statment ==--
           {% for item in range(1,11) %}
              {% if item == 5 %}
                 {% break %}          | {% continue %}    *** in /etc/ansible/ansible.cfg we need jinja2_extensions = jinja2.ext.loopcontrols
              {% endif %}
              {{ item }}
           {% endfor %}

*************************************
******** filter lists ***
*************************************
 tasks:
  - name: jinja2 task
    debug:
      msg: >
           --== Ansible Jinja2 statment ==--
          {{ [1, 2, 3, 4] | min }}
          {{ [1, 2, 3, 4] | max }}
          {{ [1, 2, 2, ,3 3, 4] | unique }}
          {{ [1, 2, 2, ,3 3, 4] | difference([1, 2, 3, 4]) }}
          {{ ['jon', 'rob', 'freddy'] | unique }}
          {{ "https://learning.oreilly.com/videos/mastering-ansible/index.htm" | urlsplit('hostname') }}
          
*************************************
******** Templates ***
*************************************
  tasks:
    - name: jinja2 templates
      template:
        src: template.j2
        dest: "/tmp/{{ ansible_hostname }}_template.out"
        trim_blocks: true

  **** next example 
    - name: template                          *** tworzenie template
        template:
          src: temp.j2          *** plik szablonu
          dest: /tmp/outtemp.txt   *** plik wynikowy

        or
        template: src=temp.j2 dest=/tmp/outtemp.txt

        >>>>> plik temp.j2: 
          Hello {{ ansible_hostname }}
          Today we have {{ ansible_date_time.date }}

*************************************
******** Patch ***
*************************************
  tasks:
    - name: Install patch
      yum:
        name: patch
        update_cache: yes
        state: latest
      when: ansible_distribution == "CentOS"
    
    - name: patch nginx.conf
      patch:                              *** modul patch
        src: file/nginx.conf.centos.patch
        dest: /etc/nginx/nginx.conf
      when: ansible_distribution == "CentOS"

*************************************
******** LVM ***
*************************************
  tasks:
  - name: Create a new primary partition for LVM
    parted:
      device: /dev/vdb
      number: 1
      flags: [ lvm ]
      state: present
      part_end: 2GiB

  - name: konfiguracjka VG
    lvg:
      vg: nfsVG
      pvs: /dev/vdb1

  - name: konfiguracja LVM
    lvol:
      vg: nfsVG
      lv: nfsLVM
      size: +100%FREE

  - name: file system na LVM
    filesystem:
      fstype: xfs
      dev: /dev/mapper/nfsVG-nfsLVM

  - name: punkt montowania
    file:
      state: directory
      path: /nfsdir

  - name: montowanie
    mount:
      path: /nfsdir
      src: /dev/mapper/nfsVG-nfsLVM
      fstype: xfs
      state: mounted

  - name: Test czy fstab jest ok
    shell: 'mount -a'

*** next example ***
---
- name: operations on disk
  hosts: ansible2
  tasks:
  - name: Przygotowanie partycji1
    parted:
      device: /dev/vdb
      number: 1
      state: present
      part_end: 4GiB

  - name: Przygotowanie partycji2
    parted:
      device: /dev/vdb
      number: 2
      state: present
      part_start: 4GiB
      part_end: 8GiB

  - name: create VG
    lvg:
      vg: vg1
      pvs: /dev/vdb1,/dev/vdb2  *** kilka partycji w jeden VG

  - name: create lvm 75% of VG
    lvol:
      vg: vg1
      lv: lvm1
      size: 75%VG             **** stworzenie LVM a zajmujacego 75% VG
 
  - name: create filesystem ext4
    filesystem:
      fstype: ext4
      dev: /dev/mapper/vg1-lvm1

  - name: resize LVM do 100% PV
    lvol:
      vg: vg1
      lv: lvm1
      size: 100%PVS
      resizefs: true  *** resize wygląda ze odrazu formatuje czyli nie jest potrzebna coś ala:
                      *** lvextend -r 
                      ani 
                        resize2fs /dev/mapper/toniema-nazwalv --- [rozszerzenie ext4]
                        xfs_growfs -L 50M /dev/mapper/toniema-nazwalv --- [rozszerzenie xfs]
  
    - name: Mount and bind a volume
    mount:
      path: /mylvm
      src: /dev/mapper/vg1-lvm1
      state: mounted                *** montuje i dodaje do fstab, jak nie ma mount pointa to go tworzy
      fstype: ext4

    - name: test mount -a
      shell: 'mount -a'

  


*************************************
******** Url test using handler ***
*************************************
  tasks:
    - name: restart server HTTP                         *** restart httpd i weryfikacja czy odpowiada kodem 200
      systemd:
        name: httpd
        state: restarted
      notify: Check HTTP service
  
      OR
      systemd:
        name=nginx state=restarted

  handlers:
  - name: Check HTTP service                            *** czy www odpowiada
      uri:
       url: http://{{ ansible_default_ipv4.address }}   *** lub jakis adres http
       status_code: 200                                 *** weryfikacja czy 200 bo to oznacza ze strona dziala
    

tasks:
    - name: check url address                           *** czy www odpowiada
      uri:
        url: http://localhost/
        url: http://{{ ansible_default_ipv4.address }}
        return_content: yes
      register: result
      until: '"Hello" in result.content'

tasks:
    - name: check url address                           *** czy www odpowiada z kodem 200
      uri:
       url: http://{{ ansible_default_ipv4.address }}
       status_code: 200

*************************************
******** firewall ***
*************************************
 tasks:
   - name: open firewall for httpd
     firewalld:
       systemd: http 
       permanent: true
       state: enabled
     notify: Reload firewall           *** przeladowanie firewalla poprzez handlers ale tylko jezeli task bedzie zrobiony

 handlers:
   - name: Reload firewall
     systemd:
       name: firewalld
       state: daemon_reload 
       
*************************************
******** Run commands in playbook ***
*************************************
!!! jeżeli task kończy sie errorem to przerywa playbooka
  "ignore_errors"  # wstawiamy pod taskiem na wysokości modułu
!!! zmienna.stdout_lines # zachowuje orginelne formatowanie wyjscia

*** wyswietli wynik komendy np.: "echo XXX" ***
    tasks:
    - name: uname command
      command: "echo ToJa"
      register: command_out
    - debug: 
        msg="{{ command_out.stdout }}" *** wyswietli wynik komendy "echo XXX"

    - name: uname command
      command: "hostname"
      register: command_out
    - debug: 
        msg="{{ command_out.stdout }}"

*** a command/shell jako nowa zmienna ***
    tasks:
    - name: uname command
      command: "hostname"
      register: var4            *** nazwa rezultatu
    - debug:  
        var=var4.stdout   *** wynik komendy to zmienna var4.stdout

    - name: uname command
      shell: "uptime|awk '{print $1}'"
      register: var4
    - debug:  
        var=var4.stdout

*** instalacja paczek ***
    tasks:
    - name: install lynx                      *** instalacja pakietu
      yum: name=lynx.x86_64 state=latest/present

*** service ***
    tasks:
    - name: start httpd
      systemd: name=httpd state=started enabled=yes


*** file - symlink *** tworzenie symlinka
    tasks:
    - name: symlink
      file: src=/../../name dest=/../../name state=link
    
  or

    tasks:
    - name: symlink
      file:
        src: /../../name
        dest: /../../name 
        state: link


*** meta ----> wykonanie hendlera w danym miejscu bezwarunkowo
    - name: Force all notified handlers to run at this point, not waiting for norma>
      meta: flush_handlers

*** url
    tasks:
    - name: check url address                   *** czy www odpowiada
      uri:
        url: http://localhost/
        return_content: yes
      register result
      until: '"Hello" in result.content'

*************************************
******** Roles **********************
*************************************
  # rola sama z siebie się nie uruchamia
  # własne role musimy mieć w dir: rols
  ~/rols

1. create directory np: roles
2. /> cd /etc/ansible/roles
3. ../roles/> ansible-galaxy init <role_name>   *** tworzy folder roli i potrzebne podkatalogi

  www.galaxy.ansible.com        # role do pobrania


**** example ****
        [ansible@wroclaw ~]$ cat users_playbook.yml 
        ---
        - name: wywolanie roli
          hosts: all
          roles:
            - userzy
            - kolejna_rola    ## roli może być wiele

          ##  możemy dodać taski taski zawsze wykonują się po roli
          ## chyba ze dodamy pre_task:
          pre_task:
          - name: task ktory ma sie wykonac przed rola
            ....

        [ansible@wroclaw roles]$ tree userzy/
        userzy/
        ├── defaults          
        │   └── main.yml        # zmienne typu port dla aplikacji itp
        ├── files               # pliki kture bedziemy kopiowac
            plik1.txt
            plik2.txt
        ├── handlers            # tu handlers
        │   └── main.yml
        ├── meta
        │   └── main.yml
        ├── README.md
        ├── tasks
        │   └── main.yml
        ├── templates           # pliki na szablony czyli pliki xxx.j2
        ├── tests
        │   ├── inventory
        │   └── test.yml
        └── vars
            └── main.yml      # zmienne dla taskow

        [ansible@wroclaw ~]$ cat roles/userzy/tasks/main.yml 
        ---
        # tasks file for userzy
        - name: grupa ''{{ group }}
          group:
            name: '{{ group }}'
            state: present
        - name: user '{{ user }}'
          user:
            name: '{{ user }}'
            state: present
            group: '{{ group }}'
        - name: katalog
          file:
            path: '{{ dir }}'
            owner: '{{ user }}'
            group: '{{ group }}'
            state: directory
            mode: 0770
            
        - name: kopiowanie
          copy:
            src: '{{ item }}'
            dest: '{{ dir }}'
          loop:
            - plik1.txt
            - plik2.txt


*************************************
******** Handlers *******************
*************************************
---
[...]

  tasks:
  - name: configure httpd
    [...]
    notify: restart httpd                 *** co trzeba zrobic jak ten task bedzie wykonany

  handlers:                               *** ta sekcja na koncu playbooka
  - name restart httpd
    systemd: name=httpd state=restarted

    # task ktory wywowala handlersa we wskazanym miejscu

  - name: Force all notified handlers to run at this point, not waiting for norma>
    meta: flush_handlers


*************************************
******** main.yml *******************
*************************************

include: <file_name>              *** dodanie pliku np kiedy mamy kilka plikow dla taskow

example:
  tasks
    |__main.yml
    |__https.yml
    |__apache.yml
  
  main.yml |--->  - include_tasks: https.yml
                  - include_tasks: apache.yml
                   
*** example ****
installinclude.yml --- palybook
  ---
  - hosts: all
  
    tasks:
      - name: install include tasks
        include: tasks/alltasks.yml         *** includ dla tasków
  ...

  ***** tasks/alltasks.yml                  *** includowany plik taskow
  ---
    - name: install ftp and Samba
      yum:
        name:
          - "{{ ansible_local.custom.packages.smb_package }}"  *** lista wykozystujaca localfacts
          - "{{ ansible_local.custom.packages.ftp_package }}"
        state: latest

    - name: start services
      systemd:
        name: "{{ item }}"
        state: started
        enabled: true
      with_items:
      - "{{ ansible_local.custom.services.smb_service }}"   *** petla "with_items" wykozystujaca localfacts
      - "{{ ansible_local.custom.services.ftp_service }}"


*************************************
******** playbook modules ***********
*************************************
*** set_fact      *** pozwala na dynamiczna zmiane facts
  tasks:
    - name: set a fact
      set_fact:
        our_fact: Ansible Rocks
        ansible_distribution: "{{ ansible_distribution | upper}}"  *** istniejacy fact nadpisujemy tak by byl napisany duzymy literami
        webserver_port: 80
        webserver_path: /user/share/www

    - name: show custom fact
      debug:
        msg: "{{ our_fact }}"
    - name: show custom fact
      debug:
        msg: "{{ ansible_distribution }}"

*** pause /*** prompt
  tasks:
    - name: pause module
      pause:
        seconds: 10
        prompt: prosze sprawdzic server jezeli dziala press continue

*** wait_for
  tasks:
    - name: wait for webserver will be running on port 80
      wait_for:
         port: 80

*** assemble                     *** mou laczy wszystkie pliki z dira conf.d/ w plik sshd_config
  tasks:
    - name: Assemble conf.d to sshd_config
      assemble:
        src: conf.d
        dest: sshd_config

*** add_host
  tasks:
    - name: add host1 to group_1 and group_2
      add_host:
        name: host1
        groups: group_1, group_2

*** group_by                   *** tworzenie grupy
    tasks:
    - name: Create group based on ansible_distribution
      group_by:
        key: "custom_{{ nsible_distribution | lower }}"  *** tworzenie okreslonej grupy ?lower ta zmiena ma byc malymi literami

*** fetch  ## moduł który pobiera pliki na dla BACKUPu
   tasks:
    - name: Fetch /etc/redhat-release
      fetch:
        src: /etc/redhat-release
        dest: /tmp/redhat-release

=============================================================================================
Playbooks
=============================================================================================
----------------------------------------------------------------
*** install httpd and add to firewall http, veryfication if we will get code 200 after HTTPD restart
----------------------------------------------------------------
---
- name: my first playbook
  hosts: all
  gather_facts: true

  tasks:
  - name: show facts
    debug:
      msg: "{{ ansible_default_ipv4.address }}"

  - name: install httpd service
    yum:
     name: httpd
     state: latest
    notify: httpd start

  - name: add http to firewall
    firewalld:
     systemd: http
     permanent: true
     state: enabled
    notify: restart firewall

  - name: check url address
    uri:
     url: http://{{ ansible_default_ipv4.address }}
     status_code: 200

  - name: restart server HTTP
    systemd:
     name: httpd
     state: restarted
    notify: Check HTTP service

  handlers:
  - name: httpd start
    systemd:
     name: httpd
     state: started
     enabled: yes

  - name: restart firewall
    systemd:
     name: firewalld
     state: reloaded

  - name: Check HTTP service
    uri:
     url: http://{{ ansible_default_ipv4.address }}
     status_code: 200

-----------------------------------------------------------------
*** compare strings *** search
----------------------------------------------------------------
---
  - name: my first playbook
    hosts: all
    gather_facts: no

    vars_files:
      - vars/vars.yml

    tasks:
    - name: check installed httpd rpm on host
      shell: "rpm -qa| grep httpd-2"
      register: httpd_rpm_check_out                     *** zapisanie do zmienne zainstalowanej wersji palkietu
    - debug: 
        msg="{{ httpd_rpm_check_out.stdout }}"          *** wyświetlenie zmiennej jako msg

    - name: compare installed httpd rpm
      debug:
        msg: "{{ rh_httpd_rpm }} is installed"
      when: httpd_rpm_check_out is search(rh_httpd_rpm)    **** porównanie search sprawdza czy w zmiennej "httpd_rpm_check_out" zawiera sie zmienna "rh_httpd_rpm"

-------------------------------------------------------------------------
*** Ansible Vault ------- kiedy potrzebujemy coś zaszyfrować np: hasło
*** secrety ***
-------------------------------------------------------------------------
  # szyfrowanie playbooka
 
      [ansible@wroclaw ~]$ ansible-vault encrypt simpleplaybook.yml 
      New Vault password: 
      Confirm New Vault password: 
      Encryption successful
  # edycja zaszyfrowanego playbooka
      [ansible@wroclaw ~]$ ansible-vault edit simpleplaybook.yml


## tworzenie usera z przekazaniem jego hasla przy tworzeniu usera za pomoca modułu: user
 ansible-vault create secret.yml # tworzymy szyfrowany plik z haslami userow 
  Steps:
  1. hasło
  2. otwiera się plik gdzie można zdefiniować variables
      username: user_name
      passwd: password

  # użycie takiego pliku np przy tworzeniu usera
    >/ cat useradd.yml
    ---
    - name: playbook na brudno
      hosts: all
      vars_files:              ### dodanie pliku secret.yml z potrezbnymi zmiennymi
        - secret.yml
      tasks:
      - name: sdd user
        user:
          name: "{{ username }}"
          password: "{{ passwd }}"
    ...

  # run secret playbook
    ansible-playbook -i hosts --ask-vault-pass useradd.yml
    ansible-playbook -i hosts --vault-password-file=<file_name> useradd.yml ### hasło do secret.yml czyta z wskazanego pliku

  # to check use command module
    ansible all -i hosts -m command -a "grep tester /etc/shadow"


 *** next example ***

  # playbook view
  >>> cat passuser.yml
    ---
      - name: Stworzenie usera z haslem z sekretow
        hosts: servers
        vars_files:
          - password.yml
        tasks:
        - name: Stworz usera
          user:
            name: secretuser
            password: "{{ pw }}"
  # content of password.yml 
  >>> ansible-vault edit password.yml 
    Vault password: 
        pw: '$6$AnCZzn6D$xMtHEfms6YKI6WBsCoaQp6uEW.oHONwC9cbp7.VijeAaNsLPUEBVWpMNNtciWXXk2fGsWKI7PGv.ehA4gJVHY1'
  # run playbook
  >>> ansible-vault passuser.yml --ask-vault-pass

 *** next example ***
  # task na dodanie userow z haslem "username123"

  - name: Tworzenie uzytkownikow z haslem username123
    user:
      name: '{{ item }}''
      state: present
      password: "{{ ( item + '123' ) | password_hash('sha512') }}"
      loop: '{{ users }}''

    
-------------------------------------------------------------------------
*** sterowanie statusem
-------------------------------------------------------------------------
    tasks:
    - name: Copy using inline content
      copy:
        content: "Test file\n"
        dest: /READMY
      failed_when: warunek ## jezeli jest spełniony to task ma sttus failed jeżeli warunek nie jest spełniony dalej się wykonuje!!!

      or/

      changed_when: warunek ## jezeli jest spełniony to task ma sttus changed w innym wypadku i tak sie wykonuje!!!

    # mozna też łączyć i rbić warunki dla obu statusów: failed i changed

      failed_when:
      - rpm_e_out.rc != 0
      - '"is already installed" not in rpm_e_out.stderr'
      changed_when:
      - rpm_e_out.rc == 0

-------------------------------------------------------------------------
*** block
-------------------------------------------------------------------------
    tasks:
    - name: Copy using inline content
      copy:
        content: "Test file\n"
        dest: /READMY

    - block:      # na tym samym wcięciu co task
      - name: task nr1
        dnf:
          ...
      - name: task nr2
        copy:
          ...
      when: ....  # na poziomie słowa block taski zostaną wykonane jezeli when jest prawdziwy

    - name: task kolejny
      fatch:
        ...

    -------------------------------------------------------------------------
    *** sekcja block -- konstrukcja rescue
    -------------------------------------------------------------------------
        tasks:
        - name: Copy using inline content
          copy:
            content: "Test file\n"
            dest: /READMY

        - block:      # na tym samym wcięciu co task
          - name: task nr1
            dnf:
              ...
          - name: task nr2
            copy:
              ...
          rescue:   # na poziomie słowa block taski ratunkowy
          - name: task ratunkowy  # mimo że jest failed w block ten task się wykona 
            ....                  # ponadto wykona się kolejny poza block - uratuje go rescue
                                  !!! jeżeli block nie zakończy się błędem to rescue się nie uruchamia
        - name: task kolejny
          fatch:
            ...

    -------------------------------------------------------------------------
    *** sekcja block -- tasks always
    -------------------------------------------------------------------------
        tasks:
        - name: Copy using inline content
          copy:
            content: "Test file\n"
            dest: /READMY

        - block:      # na tym samym wcięciu co task
          - name: task nr1
            dnf:
              ...
          - name: task nr2
            copy:
              ...
          rescue:   # na poziomie słowa block taski ratunkowy
          - name: task ratunkowy  # mimo że jest failed w block ten task się wykona 
            ....                  # ponadto wykona się kolejny poza block
                                  !!! jeżeli block nie zakończy się błędem to rescue się nie uruchamia
          always:
          - name: task always     # wykona się zawsze czy jest błąd w blocku czy nie 
                                  # jak nie ma rescue tez sie wykona ale już ostatni task się nie wykona
        - name: task kolejny
          fatch:
            ...

    - name: uruchomienie handlers
      mata: flush_handlers

    -------------------------------------------------------------------------
    *** block -- zalecana struktura playbooka
    -------------------------------------------------------------------------
      tasks:
        - name: Copy cfg          # kopia zapasaowa
          copy:
            content: "Test file\n"
            dest: /READMY

        - block:                  # task wprowadzające zmiany 
          - name: task nr1
            dnf:
              ...
          - name: task nr2
            copy:
              ...

          - name: uruchomienie handlers  # wywołuj handler również tu nie tylko na końcu
            mata: flush_handlers

          rescue:                 # taski odzyskujace zmiany z backupu
          - name: task ratunkowy  
            ....
          
        - name: task kolejny
          systemd:
            agr:
          notify: nazwa taska_handlara

      handler:
        - name: nazwa taska_handlara
          systemd:              # np restart servisu

  ***** example

  ---
- name: implementacja vsftpd
  hosts: katowice


  tasks:

  - block:      # na tym samym wcięciu co task
    - name: instalacja vsftpd
      dnf: 
        name: vsftpd
        state: latest
        
    - name: vsftpd start
      systemd:
        name: vsftpd
        state: started
        enabled: yes

    - name:
      fetch:
        src: /etc/vsftpd/vsftpd.conf
        dest: /tmp

    - name: open firewall for vsftpd
      firewalld:
        systemd: ftp
        permanent: yes
        state: enabled
        immediate: yes
        
    - name: insert line
      lineinfile:
        path: /etc/vsftpd/vsftpd.conf
        state: present
        regexp: '^anonymous_enabled=NO'
        line: 'anonymous_enabled=YES'

    - name: uruchomienie handlers   # ten task wywola handler'a
      meta: flush_handlers

    rescue:   # na poziomie słowa block taski ratunkowy
    - name: odzyskanie cfg z backup
      copy:
        src=/tmp/{{ hosts }}/etc/vsftpd/vsftpd.conf
        dest=/etc/vsftpd/vsftpd.conf
      notify: restart vsftpd

  - name: cp plik1 i plik2
    copy:
      src: '{{ item }}'
      dest: /var/ftp/pub
    loop:
        - plik1
        - plik2

  handlers:
  - name: restart vsftpd
    systemd:
      name: vsftpd
      state: restarted

#######################################################################################################
### LABy - Zadania do wykonania
#######################################################################################################
  Zadanie d3:
  # Napisz playbooka nr 1
    1. Tworzenie grupy administrator z GID 3000
    2. Tworzenie userow
    3. bob i ken maja nalezec do dodatkowej grupy administrator
    4. Ostatni task w playbooku ma wyswietlic informacje o userze bob 

  # Napisz playbooka nr 2 uzywajac osobnych PLAY lub warunkow :
    1. Na gdansku zainstaluj paczki: mariadb, httpd, php
    2. Na poznaniu zainstaluj paczki: targetcli, lftp 
        
        ---
        - name: cwiczenie dzien3
          hosts: all
          vars:
            pkg1:
              - mariadb
              - httpd
              - php
            pkg2:
              - targetcli
              - lftp
          tasks:
          - name: instalacja paczek poznan
            yum:
              name: '{{ item }}''
              state: latest
            loop: '{{ pkg1 }}'
            when: ansible_hostname == "poznan"

          - name: instalacja paczek gdansk
            yum:
              name: '{{ item }}'
              state: latest
            loop: '{{ pkg2 }}'
            when: ansible_hostname == "gdansk"


  # Zadanie ad-hoc
    1. Znajdz wszystkie pliki wieksze lub rowne 1MB w katalogu /var/log 
    moduł find

      find:
      paths: /var/log
      patterns: "^.*?\\.(?:old|log\\.gz)$"
      size: 10m
      use_regex: yes

      ansible all -m find -a 'paths=/var/log patterns="*" size=1m'

    2. Zaplanuj reboot systemu za 1min

      ansible all -m reboot -a 'reboot_timeout="3600"'

  Zadanie d4:
  1. Instalacja i uruchomienie serwisu
  2. Konfiguracja firewalla - nowy port 8080
  3. dodanie nowego folderu /www
  4. Kopiowanie index.html do nowego folderu /www
  5. stworzyc szablon architektura.j2  ## tu ma się dodać info o procesorze itp
  6. Kopiowanie szablonu jinja2 architektura.j2 /www/architektura.hml
  7. Plik konfiguracyjny: /etc/httpd/config/http.conf
  - zmiana portu na 8080 >> Listen 80 na 8080
  - zmiana folderow w konfigu 
        >> '^DocumentRoot "/var/www/html"' na '^DocumentRoot "/www"'
        >> '^<Directory "/var/www/html">' na '^<Directory "/www">'
        !!! restart uslugi po takim każdym tasku
  9. SELinux 
      moduły: sefcontext, seport
      
      semanage
        Selinux wymaga: paczki policycoreutils-python-utils

  # tworzenie roli
  ansible-galaxy init www

  # uzyć metody include_tasks:
    include_tasks: <file_name>              *** dodanie pliku np kiedy mamy kilka plikow dla taskow

      example:
        tasks
          |__main.yml
          |__https.yml
          |__apache.yml
        
        main.yml |--->  - include_tasks: https.yml
                        - include_tasks: apache.yml

  Zadanie d5
  Stworz playbooka ktory nie konczy sie jako FAILED:

  Tworzacego 3 userow krzysztof, leszek i daniel
  wszyscy maja nalezec do grupy ktora jest okreslona w zewnetrznym pliku jako zmienna 'grupa'

  W razie gdy nie ma w systemie grupy o takiej nazwie jak w zmiennej playbook powinien wyswietlic komunikat
  "Niestety brak grupy <NAZWA_GRUPY>"

  Niezaleznie od tego czy userzy zostana dodani do grupy czy nie na koncu playbooka powinien sie pojawic komunikat
  "Try harder ;)"

  W playbooku nie zamieszczaj taska z dodawaniem grupy

  Przetestuj playbooka w sytuacji gdy grupa istnieje jak i nie istnieje
  W razie potrzeby w systemie jest grupa 'student' 

  poznan ansible_port=2222 ansible_user=student



#######################################################################################################
 ## sprawdzenei wersji os np RedHat i versji 7/8 i paczki; hostname ...

    - name: get OS family
      setup:
        gather_subset: min
        filter: ansible_os_family

    - name: showing system family
      debug:
        msg: "{{ ansible_facts.os_family }}"

    - name: get OS version
      setup:
        gather_subset: min
        filter: ansible_distribution_major_version

    - name: show OS version
      debug:
        msg: "{{ ansible_facts.distribution_major_version }}"

  - name: get hostname
    setup:
      gather_subset: min
      filter: ansible_hostname

  - name: show system family
    debug:
      msg: "{{ ansible_facts.hostname }}"

#######################################################################################################
